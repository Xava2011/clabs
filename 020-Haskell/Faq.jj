
/* $Revision: 1.1 $
   $Date: 2004/03/09 20:51:28 $

   Parser skrzynki pocztowej RMAIL Emaksa.
   Program przyk³adowy z dystrybucji JavaCC.
*/

options {
    JAVA_UNICODE_ESCAPE=true;
}

PARSER_BEGIN(Faq)

import java.io.*;

public class Faq {

static int count = 0;

static int beginAt = 1;

static PrintWriter indstr;

static {
   try {
      indstr = new PrintWriter(new FileWriter("index.html"));
      indstr.println("<html><head>");
      indstr.println("<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-2\">");
      indstr.println("<title>.:Skrzynka pocztowa:.</title>");
      indstr.println("</head><body>");
      indstr.println("<h2>Skrzyñka pocztowa WB</h2>");
   } catch (IOException e) {
      throw new Error();
   }
}

static String fix(String s) {
	String retval = "";
	for (int i = 0; i < s.length(); i++) {
	    char c = s.charAt(i);
	    if (c == '<') {
		retval += "&lt;";
	    } else if (c == '>') {
		retval += "&gt;";
	    } else {
		retval += c;
	    }
	}
	return retval;
}

// FUNKCJA main

public static void main(String args[]) throws ParseException {
	if (args.length == 1) {
	    beginAt = Integer.parseInt(args[0]);
	}
	Faq parser = new Faq(System.in);
	parser.MailFile();
}

}

PARSER_END(Faq)

// PARSER SPECIFICATIONS BEGIN HERE

void MailFile() :
{}
{
    (
    {
	count++;
    }
    MailMessage()
    {
	System.out.print(count + ".");
	System.out.flush();
    }
    )*
	<EOF>
	{
	    System.out.println("");
	    indstr.close();
	}
}

void MailMessage() :
{
    PrintWriter msgstr = null;
    Token subj=null, from=null, date=null, body;
    if (count >= beginAt) {
	try {
	    msgstr = new PrintWriter(new FileWriter(count + ".html"));
	} catch (IOException e) {
	    throw new Error();
	}
    }
}
{
    ( subj=<SUBJECT> | from=<FROM> | date=<DATE> )+
	{
	    indstr.print("<a href=\"" + count + ".html\">");
	    if (subj == null) {
		indstr.println("no subject</a><br>");
	    } else {
		indstr.println(fix(subj.image) + "</a><br>");
	    }
	    if (count >= beginAt) {
		msgstr.println("<html><head>");
		msgstr.println("<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-2\">");
		msgstr.println("<title>" 
			       + ((subj==null) ? "no subject" : fix(subj.image)) 
			       + "</title></head><body>");
		msgstr.println("Subject: " 
			       + ((subj==null) ? "no subject" : fix(subj.image)) + "<br>");
		msgstr.println("From: " 
			       + ((from==null) ? "" : fix(from.image)) + "<br>");
		msgstr.println("Date: " 
			       + ((date==null) ? "" : fix(date.image)) + "<br>");
		msgstr.println("<br>");
	    }
	}
    ( body=<BODY>
	{
	    if (count >= beginAt) {
		msgstr.print(fix(body.image) + "<br>");
	    }
	}
      )*
	<END>
	{
	    if (count >= beginAt) {
		msgstr.close();
	    }
	}
}

// LEXICAL SPECIFICATIONS BEGIN HERE

TOKEN:
{
    <#EOL: "\n" | "\r" | "\r\n">
	       |
	       <#TWOEOLS: (("\n"|"\r\n") <EOL>) | ("\r\r" [ "\n" ])>
	       |
	       <#NOT_EOL: ~["\n","\r"]>
}

<DEFAULT>
    SKIP:
{
    <<EOL> "*** EOOH ***" <EOL>> : MAILHEADER
	  |
	  <~[]>
}

<MAILHEADER>
    SKIP:
{
    <_TWOEOLS: <TWOEOLS>> : MAILBODY
		    // We cannot have just a reference to a regular expression in a
		    // lexical specification - i.e., we cannot simply have <TWOEOLS>.
		    |
		    "Subject: " : MAILSUBJECT
		    |
		    "From: " : MAILFROM
		    |
		    "Date: " : MAILDATE
		    |
		    <~[]>
}

<MAILSUBJECT>
    TOKEN:
{
    <SUBJECT: ( <NOT_EOL> )+>
}

<MAILSUBJECT>
    SKIP:
{
    <_EOL1: <EOL>> : MAILHEADER
}

<MAILFROM>
    TOKEN:
{
    <FROM: ( <NOT_EOL> )+>
}

<MAILFROM>
    SKIP:
{
    <_EOL2: <EOL>> : MAILHEADER
}

<MAILDATE>
    TOKEN:
{
    <DATE: ( <NOT_EOL> )+>
}

<MAILDATE>
    SKIP:
{
    <_EOL3: <EOL>> : MAILHEADER
}

<MAILBODY>
    TOKEN:
{
    <BODY: (~["\n","\r","\u001f"])* <EOL>>
	       |
	       <END: "\u001f"> : DEFAULT
}
