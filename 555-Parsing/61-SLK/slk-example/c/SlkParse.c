
// SlkParse.c - generated by the SLK parser generator 

#include "SlkParse.h"

#define GET_CONDITIONAL_PRODUCTION( symbol )  0 
#define get_predicted_entry( a,b,c,d,e,f,g )  0 

static short Parse[] = {

0,0,17,17,17,17,16,0,17,0,17,15,15,14,14,12,12,15,1
,15,0,13,1,13,1,2,5,3,4,2,5,2,5,8,10,6,7,8,9
,8,11
};

static unsigned short Parse_row[] = {0

,16,23,26,24,32,31,32,14,10,1
,0};

static short Conflict[] = {

0
};

static unsigned short Conflict_row[] = {0


,0};

static short Production[] = {0

,0,2049,-1,2050,0,2050,2056,2052,0,2051,43,0,2051,45,0,2052,2057,2054
,0,2053,42,0,2053,47,0,2054,2058,2055,0,2055,41,2050,40,0,2055,-6,2055,45
,0,2055,-2,257,0,2056,2056,-3,2052,-2,2051,0,2056,0,2057,2057,-4,2054,-2,2053
,0,2057,0,2058,-5,2054,94,0,2058
,0};

static unsigned short Production_row[] = {0

,1,5,9,12,15,19,22,25,29,34,39,43,50,52,59,61
,66
,0};

static short Terminal_to_index[] = {0

,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0,0,0,6,7,3,1,0,2,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0
,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,8,9
};

#undef  START_SYMBOL 
#define START_SYMBOL 2049
#undef  NONTERM_INDEX
#define NONTERM_INDEX(symbol) ( symbol - (START_SYMBOL-1) )
#undef  TERMINAL_INDEX
#define TERMINAL_INDEX(token) ( Terminal_to_index [token] )

#undef  SLK_PUSH
#define SLK_PUSH(symbol,stack,top) if ( top > stack ) { *--top = symbol; \
    } else { log.trace ("SlkParse: stack overflow\n"); return; }
#undef  SLK_PUSH2
#define SLK_PUSH2(symbol,stack,top) if ( top > stack ) { *--top = symbol; \
    } else { log.trace ("get_predicted_entry: stack overflow\n"); return 0; }
#undef  SLK_POP
#define SLK_POP(top)   (*top ? *top++ : 0)

#undef  Slk_EXECUTE_ACTION 
#define Slk_EXECUTE_ACTION( action, symbol )    (*action [-symbol]) ()

short SlkGetTerminalIndex ( short   token )
{
 return ( Terminal_to_index [token] );
}

void SlkParse ( int         display,
                SlkAction   action, 
                SlkToken    tokens, 
                SlkError    error, 
                SlkLog      log, 
                short       start_symbol ) 
{
 register short *top, *production;
 short           production_number, entry, symbol, token, new_token;
 int             index, level;
 short           stack [ 512 ];

 top = stack + 511;
 *top = 0;
 if ( ! start_symbol ) {
     start_symbol = START_SYMBOL;
 }
 SLK_PUSH ( start_symbol, stack, top );
 token = tokens.get();
 new_token = token;
 if ( display ) {
     log.trace ( "\n\n\t\tPARSE DERIVATION\n\n" );
 }

 for ( symbol = SLK_POP ( top );  symbol;  ) {

     if ( symbol >= START_SYMBOL ) {                  // nonterminal symbol

         entry = 0;
         level = 1;
         production_number = GET_CONDITIONAL_PRODUCTION ( symbol );
         if ( production_number ) {
             entry = get_predicted_entry ( display, tokens, log,
                                           production_number, token,
                                           level, 1 );
         }
         if ( ! entry ) {
             index = Parse_row [NONTERM_INDEX (symbol)];
             index += TERMINAL_INDEX (token);
             entry = Parse [ index ];
         }
         while ( entry < 0 ) {
             index = Conflict_row [-entry];
             index += TERMINAL_INDEX (tokens.peek (level));
             entry = Conflict [ index ];
             ++level;
         }
         if ( entry ) {
             production = &Production [ Production_row [entry] ];
             if ( *++production == symbol ) {           // valid row for lhs
                 while ( *++production ) {
                     SLK_PUSH ( *production, stack, top );
                 }
                 if ( display ) {
                     log.trace_production ( entry );
                 }
             } else {                                   // lhs does not match
                 new_token = error.no_entry ( symbol, token, level-1 );
             }
         } else {                                       // no table entry
             new_token = error.no_entry ( symbol, token, level-1 );
         }

     } else if ( symbol > 0 ) {                         // terminal symbol
         if ( symbol == token ) {
             token = tokens.get();
             new_token = token;
         } else {                                       // token mismatch
             new_token = error.mismatch ( symbol, token );
         }

     } else {                                           // action symbol
         if ( display ) {
             log.trace_action ( symbol );
         }
         Slk_EXECUTE_ACTION ( action, symbol );
     }

     if ( token != new_token ) {
         if ( new_token ) {
             token = new_token;
         }
         if ( token != END_OF_SLK_INPUT_ ) {
             continue;                                  // try this token
         }
     }

     symbol = SLK_POP ( top );
 }

 if ( token != END_OF_SLK_INPUT_ ) {                    // input left over
     error.input_left ();
 }

}

